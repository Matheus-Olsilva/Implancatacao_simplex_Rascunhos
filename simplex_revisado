import re
import numpy as np

class SimplexRevisado:
    def __init__(self, caminho_arquivo):
        self.caminho_arquivo = caminho_arquivo
        self.eh_max = True
        self.num_variaveis = 0
        self.num_restricoes = 0
        self.coef_objetivo = []
        self.restricoes_esq = []
        self.restricoes_dir = []
        self.tipos_restricoes = []
        
        # Matrizes
        self.A = None                
        self.b = None                
        self.c = None                
        self.vars_basicas = []       
        self.vars_nao_basicas = []   
        self.B = None                
        self.B_inv = None            
        self.x_B = None              
        self.y = None                
        
        # Variáveis artificiais
        self.tem_artificial = False
        self.vars_artificiais = []
        self.num_artificiais = 0
        self.num_folga_excesso = 0
        self.precos_sombra = []

    def ler_arquivo(self):
        with open(self.caminho_arquivo, 'r') as arquivo:
            linhas = arquivo.readlines()
        
        # Função objetivo
        linha_obj = linhas[0].strip()
        if 'Max' in linha_obj:
            self.eh_max = True
        elif 'Min' in linha_obj:
            self.eh_max = False
        
        # Coeficientes da função objetivo
        expr_obj = linha_obj.split('=')[1].strip()
        termos = re.findall(r'([+-]?\s*\d*\.?\d*)\s*x(\d+)', expr_obj)
        
        indices_var = [int(idx) for _, idx in termos]
        self.num_variaveis = max(indices_var)
        self.coef_objetivo = [0] * self.num_variaveis
        
        for coef, var_idx in termos:
            coef = coef.replace(' ', '')
            if coef == '+' or coef == '':
                coef = 1
            elif coef == '-':
                coef = -1
            else:
                coef = float(coef)
            self.coef_objetivo[int(var_idx) - 1] = float(coef)
        
        # Restrições
        for i in range(1, len(linhas)):
            linha = linhas[i].strip()
            if not linha:
                continue
            
            if '<=' in linha:
                esq, dir = linha.split('<=')
                tipo = '<='
            elif '>=' in linha:
                esq, dir = linha.split('>=')
                tipo = '>='
            elif '=' in linha and not ('>' in linha or '<' in linha):
                esq, dir = linha.split('=')
                tipo = '='
            else:
                continue
            
            # Lado esquerdo
            termos = re.findall(r'([+-]?\s*\d*\.?\d*)\s*x(\d+)', esq)
            coefs_esq = [0] * self.num_variaveis
            
            for coef, var_idx in termos:
                coef = coef.replace(' ', '')
                if coef == '+' or coef == '':
                    coef = 1
                elif coef == '-':
                    coef = -1
                else:
                    coef = float(coef)
                coefs_esq[int(var_idx) - 1] = float(coef)
            
            # Lado direito
            val_dir = float(dir.strip())
            
            self.restricoes_esq.append(coefs_esq)
            self.restricoes_dir.append(val_dir)
            self.tipos_restricoes.append(tipo)
        
        self.num_restricoes = len(self.restricoes_dir)

    def forma_padrao(self):
        # Contagem de variáveis extras
        self.num_folga_excesso = self.num_restricoes
        self.num_artificiais = 0
        
        for tipo in self.tipos_restricoes:
            if tipo == '=' or tipo == '>=':
                self.num_artificiais += 1
                self.tem_artificial = True
        
        # Total de variáveis
        total_vars = self.num_variaveis + self.num_folga_excesso + self.num_artificiais
        
        # Inicializar matrizes
        self.A = np.zeros((self.num_restricoes, total_vars))
        self.b = np.array(self.restricoes_dir)
        self.c = np.zeros(total_vars)
        
        # Função objetivo
        for j in range(self.num_variaveis):
            if self.eh_max:
                self.c[j] = self.coef_objetivo[j]
            else:
                self.c[j] = -self.coef_objetivo[j]
        
        # Matriz de restrições com variáveis auxiliares
        indice_artificial = self.num_variaveis + self.num_folga_excesso
        self.vars_artificiais = []
        
        for i in range(self.num_restricoes):
            tipo = self.tipos_restricoes[i]
            
            # Coeficientes originais
            for j in range(self.num_variaveis):
                self.A[i, j] = self.restricoes_esq[i][j]
            
            # Variáveis de folga/excesso/artificiais
            if tipo == '<=':
                self.A[i, self.num_variaveis + i] = 1  # Folga
            elif tipo == '>=':
                self.A[i, self.num_variaveis + i] = -1  # Excesso
                self.A[i, indice_artificial] = 1  # Artificial
                self.vars_artificiais.append(indice_artificial)
                indice_artificial += 1
            elif tipo == '=':
                self.A[i, indice_artificial] = 1  # Artificial
                self.vars_artificiais.append(indice_artificial)
                indice_artificial += 1
        
        # Correção para RHS negativo
        for i in range(self.num_restricoes):
            if self.b[i] < 0:
                self.b[i] = -self.b[i]
                self.A[i, :] = -self.A[i, :]
        
        # Inicializar base
        self.vars_basicas = []
        for i in range(self.num_restricoes):
            if self.tipos_restricoes[i] == '<=':
                self.vars_basicas.append(self.num_variaveis + i)
            else:
                indice = self.vars_artificiais.pop(0)
                self.vars_basicas.append(indice)
        
        # Variáveis não-básicas
        self.vars_nao_basicas = [j for j in range(total_vars) if j not in self.vars_basicas]
        
        # Matriz de base e sua inversa
        self.B = self.A[:, self.vars_basicas]
        self.B_inv = np.linalg.inv(self.B)

    def fase_um(self):
        if not self.tem_artificial:
            return True
        
        # Salvar vetor de custo original
        c_original = self.c.copy()
        
        # Função objetivo da Fase I
        self.c = np.zeros_like(self.c)
        for j in range(self.c.shape[0]):
            if j >= self.num_variaveis + self.num_folga_excesso:
                self.c[j] = -1  
        
        # Resolver problema auxiliar
        if not self.simplex_revisado():
            return False
        
        # Verificar variáveis artificiais
        for i, var in enumerate(self.vars_basicas):
            if var >= self.num_variaveis + self.num_folga_excesso and self.x_B[i] > 1e-6:
                return False
        
        # Remover artificiais da base
        for i in range(len(self.vars_basicas)):
            if self.vars_basicas[i] >= self.num_variaveis + self.num_folga_excesso:
                for j in self.vars_nao_basicas:
                    if j < self.num_variaveis + self.num_folga_excesso:
                        a_j = self.A[:, j]
                        d = self.B_inv @ a_j
                        
                        if abs(d[i]) > 1e-6:
                            # Troca de base
                            theta = self.x_B[i] / d[i]
                            self.x_B = self.x_B - theta * d
                            self.x_B[i] = theta
                            
                            # Atualizar inversa
                            E = np.eye(len(self.vars_basicas))
                            E[:, i] = -d / d[i]
                            E[i, i] = 1 / d[i]
                            self.B_inv = E @ self.B_inv
                            
                            # Atualizar variáveis
                            var_saida = self.vars_basicas[i]
                            self.vars_basicas[i] = j
                            self.vars_nao_basicas.remove(j)
                            self.vars_nao_basicas.append(var_saida)
                            break
        
        # Restaurar função objetivo original
        self.c = c_original
        self.B = self.A[:, self.vars_basicas]
        
        return True

    def simplex_revisado(self):
        # Solução básica inicial
        self.x_B = self.B_inv @ self.b
        
        for iteracao in range(100): 
            # Passo 1: Variáveis duais
            c_B = self.c[self.vars_basicas]
            self.y = c_B @ self.B_inv
            
            # Passo 2: Custos reduzidos
            var_entrada = -1
            custo_max = 1e-10
            
            for k, j in enumerate(self.vars_nao_basicas):
                a_j = self.A[:, j]
                custo_reduzido = self.c[j] - self.y @ a_j
                
                if custo_reduzido > custo_max:
                    custo_max = custo_reduzido
                    var_entrada = j
            
            # Verificar otimalidade
            if custo_max <= 1e-10:
                break
            
            # Passo 3: Direção simplex
            a_q = self.A[:, var_entrada]
            d = self.B_inv @ a_q
            
            # Verificar ilimitabilidade
            if all(d_i <= 1e-10 for d_i in d):
                return False
            
            # Passo 4: Teste da razão
            theta = float('inf')
            indice_saida = -1
            
            for i in range(len(self.x_B)):
                if d[i] > 1e-10:
                    razao = self.x_B[i] / d[i]
                    if razao < theta:
                        theta = razao
                        indice_saida = i
            
            if indice_saida == -1:
                return False
            
            var_saida = self.vars_basicas[indice_saida]
            
            # Passo 5: Atualizar solução
            self.x_B = self.x_B - theta * d
            self.x_B[indice_saida] = theta
            
            # Passo 6: Atualizar inversa
            E = np.eye(len(self.vars_basicas))
            E[:, indice_saida] = -d / d[indice_saida]
            E[indice_saida, indice_saida] = 1 / d[indice_saida]
            self.B_inv = E @ self.B_inv
            
            # Passo 7: Atualizar conjuntos de variáveis
            self.vars_basicas[indice_saida] = var_entrada
            self.vars_nao_basicas.remove(var_entrada)
            self.vars_nao_basicas.append(var_saida)
            self.B = self.A[:, self.vars_basicas]
        
        # Preços sombra
        self.precos_sombra = self.y
        if not self.eh_max:
            self.precos_sombra = -self.y
        
        return True

    def solucao_primal(self):
        solucao = np.zeros(self.num_variaveis)
        
        for i, var in enumerate(self.vars_basicas):
            if var < self.num_variaveis:
                solucao[var] = self.x_B[i]
        
        # Valor da função objetivo
        valor_obj = 0
        for i, var in enumerate(self.vars_basicas):
            if var < self.num_variaveis:
                if self.eh_max:
                    valor_obj += self.coef_objetivo[var] * self.x_B[i]
                else:
                    valor_obj -= self.coef_objetivo[var] * self.x_B[i]
        
        return solucao, valor_obj
    
    def solucao_dual(self):
        return self.precos_sombra
    
    def executar(self):
        # Passos iniciais
        self.ler_arquivo()
        self.forma_padrao()
        
        # Fase I
        if not self.fase_um():
            print("O problema não tem solução viável.")
            return
        
        # Fase II
        if self.simplex_revisado():
            # Soluções
            solucao_primal, valor_obj = self.solucao_primal()
            solucao_dual = self.solucao_dual()
            
            # Resultados
            print("\n==== SOLUÇÃO PRIMAL ====")
            print(f"Valor Ótimo: {valor_obj}")
            print("Variáveis:")
            for i, val in enumerate(solucao_primal):
                print(f"  x{i+1} = {val}")
            
            print("\n==== SOLUÇÃO DUAL (PREÇOS SOMBRA) ====")
            for i, val in enumerate(solucao_dual):
                print(f"  Restrição {i+1}: {val}")
        else:
            print("O problema é ilimitado.")


# Função principal
def main():
    import sys
    
    if len(sys.argv) < 2:
        print("Uso: python simplex_revisado.py arquivo_entrada.txt")
        return
    
    caminho_arquivo = sys.argv[1]
    solver = SimplexRevisado(caminho_arquivo)
    solver.executar()


if __name__ == "__main__":
    main()